{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf600
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red255\green255\blue255;}
{\*\expandedcolortbl;;\csgray\c0;\csgray\c100000;}
\margl1440\margr1440\vieww25100\viewh15220\viewkind0
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f0\fs22 \cf2 \cb3 \CocoaLigature0 Wrote profile results to do_single_problem_rs.py.lprof\
Timer unit: 1e-06 s\
\
Total time: 8.95158 s\
File: /Users/matthaberland/Desktop/scipydev/scipy/scipy/optimize/_linprog_rs.py\
Function: _phase_one at line 21\
\
Line #      Hits         Time  Per Hit   % Time  Line Contents\
==============================================================\
    21                                           @profile\
    22                                           def _phase_one(A, b, maxiter, tol, maxupdate, mast, pivot):\
    23                                               """\
    24                                               The purpose of phase one is to find an initial basic feasible solution\
    25                                               (BFS) to the original problem.\
    26                                           \
    27                                               Generates an auxiliary problem with a trivial BFS and an objective that\
    28                                               minimizes infeasibility of the original problem. Solves the auxiliary\
    29                                               problem using the main simplex routine (phase two). This either yields\
    30                                               a BFS to the original problem or determines that the original problem is\
    31                                               infeasible. If feasible, phase one detects redundant rows in the original\
    32                                               constraint matrix and removes them, then chooses additional indices as\
    33                                               necessary to complete a basis/BFS for the original problem.\
    34                                               """\
    35                                           \
    36         1          2.0      2.0      0.0      m, n = A.shape\
    37         1          1.0      1.0      0.0      status = 0\
    38                                           \
    39                                               # generate auxiliary problem to get initial BFS\
    40         1      45913.0  45913.0      0.5      A, b, c, basis, x = _generate_auxiliary_problem(A, b)\
    41                                           \
    42                                               # solve auxiliary problem\
    43         1          2.0      2.0      0.0      x, basis, status, iter_k = _phase_two(c, A, x, basis, maxiter,\
    44         1    8757003.0 8757003.0     97.8                                            tol, maxupdate, mast, pivot)\
    45                                           \
    46                                               # check for infeasibility\
    47         1         32.0     32.0      0.0      residual = c.dot(x)\
    48         1          6.0      6.0      0.0      if status == 0 and residual > tol:\
    49                                                   status = 2\
    50                                           \
    51                                               # detect redundancy\
    52                                               # TODO: consider removing this?\
    53         1       9522.0   9522.0      0.1      B = A[:, basis]\
    54         1          2.0      2.0      0.0      try:\
    55         1     123063.0 123063.0      1.4          rank_revealer = solve(B, A[:, :n])\
    56         1      11825.0  11825.0      0.1          z = _find_nonzero_rows(rank_revealer, tol)\
    57                                           \
    58                                                   # eliminate redundancy\
    59         1       4101.0   4101.0      0.0          A = A[z, :n]\
    60         1         26.0     26.0      0.0          b = b[z]\
    61                                               except (LinAlgError, LinAlgError2):\
    62                                                   status = 4\
    63                                           \
    64                                               # form solution to original problem\
    65         1         28.0     28.0      0.0      x = x[:n]\
    66         1          7.0      7.0      0.0      m = A.shape[0]\
    67         1         36.0     36.0      0.0      basis = basis[basis < n]\
    68                                           \
    69                                               # if feasible, choose additional indices to complete basis\
    70         1          5.0      5.0      0.0      if status == 0 and len(basis) < m:\
    71                                                   basis = _get_more_basis_columns(A, basis)\
    72                                           \
    73         1          3.0      3.0      0.0      return x, basis, A, b, residual, status, iter_k\
\
Total time: 12.1079 s\
File: /Users/matthaberland/Desktop/scipydev/scipy/scipy/optimize/_linprog_rs.py\
Function: _phase_two at line 209\
\
Line #      Hits         Time  Per Hit   % Time  Line Contents\
==============================================================\
   209                                           @profile\
   210                                           def _phase_two(c, A, x, b, maxiter, tol, maxupdate, mast, pivot):\
   211                                               """\
   212                                               The heart of the simplex method. Beginning with a basic feasible solution,\
   213                                               moves to adjacent basic feasible solutions successively lower reduced cost.\
   214                                               Terminates when there are no basic feasible solutions with lower reduced\
   215                                               cost or if the problem is determined to be unbounded.\
   216                                           \
   217                                               This implementation follows the revised simplex method based on LU\
   218                                               decomposition. Rather than maintaining a tableau or an inverse of the\
   219                                               basis matrix, we keep a factorization of the basis matrix that allows\
   220                                               efficient solution of linear systems while avoiding stability issues\
   221                                               associated with inverted matrices.\
   222                                               """\
   223         2          6.0      3.0      0.0      m, n = A.shape\
   224         2          2.0      1.0      0.0      status = 0\
   225         2         25.0     12.5      0.0      a = np.arange(n)                    # indices of columns of A\
   226         2          7.0      3.5      0.0      ab = np.arange(m)                   # indices of columns of B\
   227         2          2.0      1.0      0.0      if maxupdate:\
   228                                                   # basis matrix factorization object; similar to B = A[:, b]\
   229         2     262621.0 131310.5      2.2          B = BGLU(A, b, maxupdate, mast)\
   230                                               else:\
   231                                                   B = LU(A, b)\
   232                                           \
   233       853       1791.0      2.1      0.0      for iteration in range(maxiter):\
   234                                           \
   235       853      17243.0     20.2      0.1          bl = np.zeros(len(a), dtype=bool)\
   236       853       8623.0     10.1      0.1          bl[b] = 1\
   237                                           \
   238       853       7607.0      8.9      0.1          xb = x[b]       # basic variables\
   239       853       6377.0      7.5      0.1          cb = c[b]       # basic costs\
   240                                           \
   241       853       1219.0      1.4      0.0          try:\
   242       853    1860093.0   2180.6     15.4              v = B.solve(cb, transposed=True)    # similar to v = solve(B.T, cb)\
   243                                                   except LinAlgError:\
   244                                                       status = 4\
   245                                                       break\
   246                                           \
   247       853     760176.0    891.2      6.3          c_hat = c - v.dot(A)    # reduced cost\
   248       853      28941.0     33.9      0.2          c_hat = c_hat[~bl]\
   249                                                   # Above is much faster than:\
   250                                                   # N = A[:, ~bl]                 # slow!\
   251                                                   # c_hat = c[~bl] - v.T.dot(N)\
   252                                                   # Can we perform the mulitplication only on the nonbasic columns?\
   253                                           \
   254       853      48438.0     56.8      0.4          if np.all(c_hat >= -tol):  # all reduced costs positive -> terminate\
   255         2          4.0      2.0      0.0              break\
   256                                           \
   257       851      39237.0     46.1      0.3          j = _select_enter_pivot(c_hat, bl, a, rule=pivot, tol=tol)\
   258       851    1834451.0   2155.6     15.2          u = B.solve(A[:, j])        # similar to u = solve(B, A[:, j])\
   259                                           \
   260       851      12538.0     14.7      0.1          i = u > tol                 # if none of the u are positive, unbounded\
   261       851      15791.0     18.6      0.1          if not np.any(i):\
   262                                                       status = 3\
   263                                                       break\
   264                                           \
   265       851      14263.0     16.8      0.1          th = xb[i]/u[i]\
   266       851      12916.0     15.2      0.1          l = np.argmin(th)           # implicitly selects smallest subscript\
   267       851       2718.0      3.2      0.0          th_star = th[l]             # step size\
   268                                           \
   269       851      29999.0     35.3      0.2          x[b] = x[b] - th_star*u     # take step\
   270       851       2044.0      2.4      0.0          x[j] = th_star\
   271       851    7136468.0   8386.0     58.9          B.update(ab[i][l], j)       # modify basis\
   272       851       4260.0      5.0      0.0          b = B.b                     # similar to b[ab[i][l]] = j\
   273                                               else:\
   274                                                   status = 1\
   275                                           \
   276         2          3.0      1.5      0.0      return x, b, status, iteration\
\
Total time: 12.3478 s\
File: /Users/matthaberland/Desktop/scipydev/scipy/scipy/optimize/_linprog_rs.py\
Function: _linprog_rs at line 280\
\
Line #      Hits         Time  Per Hit   % Time  Line Contents\
==============================================================\
   280                                           @profile\
   281                                           def _linprog_rs(c, c0, A, b, callback=None, maxiter=1000, tol=1e-12,\
   282                                                           maxupdate=10, mast=False, pivot="mrc", **unknown_options):\
   283                                               """\
   284                                               Solve the following linear programming problem via a two-phase\
   285                                               revised simplex algorithm.::\
   286                                           \
   287                                                   minimize:     c^T @ x\
   288                                           \
   289                                                   subject to:  A @ x == b\
   290                                                                0 <= x < oo\
   291                                           \
   292                                               Parameters\
   293                                               ----------\
   294                                               c : 1D array\
   295                                                   Coefficients of the linear objective function to be minimized.\
   296                                               c0 : float\
   297                                                   Constant term in objective function due to fixed (and eliminated)\
   298                                                   variables. (Currently unused.)\
   299                                               A : 2D array\
   300                                                   2D array which, when matrix-multiplied by ``x``, gives the values of\
   301                                                   the equality constraints at ``x``.\
   302                                               b : 1D array\
   303                                                   1D array of values representing the RHS of each equality constraint\
   304                                                   (row) in ``A_eq``.\
   305                                               callback : callable, optional (Currently unused.)\
   306                                           \
   307                                               Options\
   308                                               -------\
   309                                               maxiter : int\
   310                                                  The maximum number of iterations to perform in either phase.\
   311                                               tol : float\
   312                                                   The tolerance which determines when a solution is "close enough" to\
   313                                                   zero in Phase 1 to be considered a basic feasible solution or close\
   314                                                   enough to positive to serve as an optimal solution.\
   315                                               maxupdate : int\
   316                                                   The maximum number of updates performed on the LU factorization.\
   317                                                   After this many updates is reached, the basis matrix is factorized\
   318                                                   from scratch.\
   319                                               mast : bool\
   320                                                   Minimize Amortized Solve Time. If enabled, the average time to solve\
   321                                                   a linear system using the basis factorization is measured. Typically,\
   322                                                   the average solve time will decrease with each successive solve after\
   323                                                   initial factorization, as factorization takes much more time than the\
   324                                                   solve operation (and updates). Eventually, however, the updated\
   325                                                   factorization becomes sufficiently complex that the average solve time\
   326                                                   begins to increase. When this is detected, the basis is refactorized\
   327                                                   from scratch. Enable this option to maximize speed at the risk of\
   328                                                   nondeterministic behavior. Ignored if ``maxupdate`` is 0.\
   329                                               pivot : "mrc" or "bland"\
   330                                                   Pivot rule: Minimum Reduced Cost (default) or Bland's rule. Choose\
   331                                                   Bland's rule if iteration limit is reached and cycling is suspected.\
   332                                           \
   333                                               Returns\
   334                                               -------\
   335                                               x : 1D array\
   336                                                   Solution vector.\
   337                                               status : int\
   338                                                   An integer representing the exit status of the optimization::\
   339                                           \
   340                                                    0 : Optimization terminated successfully\
   341                                                    1 : Iteration limit reached\
   342                                                    2 : Problem appears to be infeasible\
   343                                                    3 : Problem appears to be unbounded\
   344                                                    4 : Numerical difficulties encountered\
   345                                                    5 : No constraints; turn presolve on\
   346                                           \
   347                                               message : str\
   348                                                   A string descriptor of the exit status of the optimization.\
   349                                               iteration : int\
   350                                                   The number of iterations taken to solve the problem.\
   351                                               """\
   352                                           \
   353         1         10.0     10.0      0.0      _check_unknown_options(unknown_options)\
   354                                           \
   355         1          4.0      4.0      0.0      messages = ["Optimization terminated successfully.",\
   356         1          0.0      0.0      0.0                  "Iteration limit reached.",\
   357         1          1.0      1.0      0.0                  "The problem appears infeasible, as the phase one auxiliary "\
   358                                                           "problem terminated successfully with a residual of \{0:.1e\}, "\
   359                                                           "greater than the tolerance \{1\} required for the solution to "\
   360                                                           "be considered feasible. Consider increasing the tolerance to "\
   361                                                           "be greater than \{0:.1e\}. If this tolerance is unnaceptably "\
   362                                                           "large, the problem is likely infeasible.",\
   363         1          1.0      1.0      0.0                  "The problem is unbounded, as the simplex algorithm found "\
   364                                                           "a basic feasible solution from which there is a direction "\
   365                                                           "with negative reduced cost in which all decision variables "\
   366                                                           "increase.",\
   367         1          0.0      0.0      0.0                  "Numerical difficulties encountered; consider trying "\
   368                                                           "method='interior-point'.",\
   369         1          1.0      1.0      0.0                  "Problems with no constraints are trivially solved; please "\
   370                                                           "turn presolve on."\
   371                                                           ]\
   372                                           \
   373         1          3.0      3.0      0.0      if A.size == 0:  # address test_unbounded_below_no_presolve_corrected\
   374                                                   return np.zeros(c.shape), 5, messages[5], 0\
   375                                           \
   376         1          0.0      0.0      0.0      x, basis, A, b, residual, status, iteration = _phase_one(A, b, maxiter,\
   377         1          1.0      1.0      0.0                                                               tol, maxupdate,\
   378         1    8953872.0 8953872.0     72.5                                                               mast, pivot)\
   379         1          6.0      6.0      0.0      if status == 0:\
   380         1          2.0      2.0      0.0          x, basis, status, iteration = _phase_two(c, A, x, basis,\
   381         1          1.0      1.0      0.0                                                   maxiter, tol, maxupdate,\
   382         1    3393902.0 3393902.0     27.5                                                   mast, pivot)\
   383                                           \
   384         1          7.0      7.0      0.0      return x, status, messages[status].format(residual, tol), iteration\
}