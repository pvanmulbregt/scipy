#cython: boundscheck=False, cdivision=False, wraparound=False

from __future__ import division

import cython
# from libc.stdio cimport printf, fflush, stdout
from libc.math cimport ceil, fabs, M_PI, modf, round, abs
from libc.float cimport DBL_MAX
from scipy.special._complexstuff cimport number_t, nan, zlog, zabs, double_complex, zpack, npy_isfinite, zsqrt
from scipy.special._trig cimport sinpi, cospi
# from ._cephes cimport zeta, psi
# from . cimport sf_error

# import numpy as np
# cimport numpy as np
from scipy.special._complexstuff cimport *

from libc.math cimport pow, sqrt, floor, log, log1p, exp, M_PI, fabs

# _MAX_EXPABLE = log(np.finfo(float).max)
cdef double _MAX_EXPABLE = log(DBL_MAX)

cdef inline double_complex _exppi(double_complex z) nogil:
    cdef double r = exp(M_PI * z.real)
    return zpack(r * cospi(z.imag), r * sinpi(z.imag))

@cython.cdivision(True)
cdef inline long _gcd(long m, long n) nogil:
    r"""Return the gcd of two integers m and n"""
    cdef long r
    if m < 0:
        m = -m
    if n < 0:
        n = -n
    elif n == 0:
        return m
    if m == 0:
        return n
    while True:
        r = m % n
        m, n = n, r
        if n == 0:
            return m

cdef int JS2Mod8[8]
JS2Mod8[:]= [0, 1, 0, -1, 0, -1, 0, 1]

# @cython.cdivision(True)
cdef inline int _jacobiSymbol(long a, long b) nogil:
    if b < 0:
        return 0
    if b % 2 == 0:
        return 0
    cdef int sym = 1
    cdef int pw2
#     sym = 1
    while True:
        if b == 1:
            break
        a = a % b
        if a == 0:
            sym = 0
            break
        # Remove 2's from the numerator
        pw2 = 0
        while a % 2 == 0:
            pw2 += 1
            a //= 2
        if pw2 % 2:
            sym *= JS2Mod8[b % 8]
        if a == 1:
            break
        if _gcd(a, b) != 1:
            sym = 0
            break
        # Quadratic Reciprocity
        if b % 4 == 3 and a % 4 == 3:
            sym *= -1
        a, b = b, a
    return sym

cdef inline int _leftTranslate(long *mob, long q) nogil:
    # multiply by [[1, q], [0, 1])
    mob[0] += q * mob[2]
    mob[1] += q * mob[3]
    return  0

cdef inline int _leftFlip(long *mob, long q) nogil:
    # multiply by [[0, -1], [1, 0]])
    mob[0], mob[2] = -mob[2], mob[0]
    mob[1], mob[3] = -mob[3], mob[1]
    return  0

cdef inline double_complex _transform(long *mob, double_complex tau) nogil:
    cdef double_complex ctauplusd, t1, atauplusb
    cdef double tfrac, taui
    cdef int tint
    if not npy_isfinite(tau.imag):
        if mob[2] != 0:
            return (mob[0]*1.0)/mob[2]
        return tau

    tint = <int>floor(tau.real)
    tfrac = tau.real - tint
    taui = tau.imag
    ctauplusd = zpack((mob[2]*tint + mob[3]) + mob[2]*tfrac, mob[2]*taui)
    if ctauplusd == 0:
        return 1.0j * inf
    atauplusb = zpack((mob[0]*tint + mob[1]) + mob[0]*tfrac, mob[0]*taui)
    t1 = atauplusb/ctauplusd
    return t1

cdef inline double_complex _findShortTau(double_complex tau, bint mod2, long *mob) nogil:
    r"""Find shortest tau2 = c*tau+d in the lattice generated by tau and 1.

    Returns shortest c*tau+d, M
    where M=matrix(a,b,c,d) in SL(2, Z)
    I.e. c*tau+z is small, M(tau) is as high as it can be."""
    cdef double_complex u = tau
    cdef double_complex v = 1
    cdef complex v2
    cdef double n, R, T
    cdef int dd
    cdef long q
    cdef long a=0, b=0, c=0, d=1
    cdef double U, V, V2
#     a=1
#     b=0
#     c=0
#     d=1
    U = u.real * u.real + u.imag * u.imag
    V = 1
    dd = 1
    if mod2:
        dd = 2
    while True:
        if U < V:
            u, v = -v, u
            U, V = V, U
            a, b, c, d = -c, -d, a, b
            continue
        n = u.real*v.real - u.imag*v.imag
        R = n / V
        q = dd * <long>(round(R / dd))
        if q == 0:
            break
        T = U - 2 * q * n + q * q * V
        if T >= V:
            break
        a += q*c
        b += q*d
        v2 = u - q * v
        V2 = v2.real*v2.real + v2.imag*v2.imag
        u, v = -v, v2  # WARNING: Note -v here in 1st expr, not v
        U, V = V, V2
        a, b, c, d = -c, -d, a, b
    if c < 0:
        a, b, c, d = -a, -b, -c, -d
    tau = v
    mob[0] = a
    mob[1] = b
    mob[2] = c
    mob[3] = d
    return tau


cdef inline double_complex _findHighTau(double_complex tau, bint mod2, long *mob) nogil:
    r"""Find an equivalent value in the fundamental domain for SL_2(Z), one with highest Imag(tau)

    """
    cdef double_complex tau2, bigTau
    cdef int dd=1
    cdef long q
#     cdef long a, b, c, d

    tau2 = _findShortTau(tau, mod2, mob)
    bigTau = _transform(mob, tau)
    # assert bigTau.imag > 0, str([tau, bigTau, M])
#     dd = 1
    if mod2:
        dd = 2
    # Move it back to |Re(z)<= 1|
    if fabs(bigTau.real) > 1:
        q = <long>(dd * round(bigTau.real / dd))
        bigTau -= q
        _leftTranslate(mob, -q)

    return bigTau


cdef inline double_complex _theta_raw_slow(double_complex z, double_complex tau, int n) nogil:
    cdef double_complex Sp, Sm
    cdef int k
    cdef double_complex lq, le, lp, lm
    Sp = zpack(0, 0)
    Sm = zpack(0, 0)
    for k in range(1, n + 1):
        if 0:
            # cdef double pi
            # pi = M_PI
            # lq = pi * 1j * tau * k ** 2
            # le = 2 * pi * 1j * z * k
            # lp = lq + le
            # lm = lq - le
            # Sp += np.exp(lp)
            # Sm += np.exp(lm)
            pass
        else:
            lq =  1j * tau * k ** 2
            le = 2 * 1j * z * k
            lp = lq + le
            lm = lq - le
            if 1:
                Sp += _exppi(lp)
                Sm += _exppi(lm)
            else:
                Sp += 2 * _exppi(lq) * cospi(2 * z * k)
    return (Sm + Sp) + 1


cdef inline double_complex _theta_raw(double_complex z, double_complex tau) nogil:
    cdef double_complex Sp, Sm, q, eta, etainv, qpwr, Stotal
    cdef int k, n
    cdef double pi=M_PI, a, b, c, disc, nr
    # assert tau.imag > 0, str([tau, z])
    # q = np.exp(np.pi * 1j * tau)
    q = _exppi(tau * 1j)
    if q == 0:
        return 1

    # Compute how many terms needed
#     pi = M_PI
    a = pi * tau.imag
    b = fabs(2 * pi * z.imag)
    c = -52 * log(2.0)
    disc = b ** 2 - 4 * a * c
    nr = (-b + sqrt(disc)) / 2.0 / a
    n = <int>(ceil(nr)) + 1

    if b > _MAX_EXPABLE:
        Stotal = _theta_raw_slow(z, tau, n)
    else:
        eta = _exppi(2  * 1j * z)
        etainv = _exppi(-2 * 1j * z)
        Sp = 1
        Sm = 1
        while n > 1:
            qpwr = q ** (2 * n - 1)
            Sp = 1 + eta * qpwr * Sp
            Sm = 1 + etainv * qpwr * Sm
            n -= 1
        Sp *= eta * q
        Sm *= etainv * q
        Stotal = (Sp + Sm) + 1
    return Stotal


# cdef inline double_complex _jacobi_theta(double_complex z, double_complex tau) nogil:
cdef inline double_complex _jtheta_complex(double_complex z, double_complex tau) nogil:
    cdef double_complex z1, tau1, ctauplusd, jval, zeta, lz, tauHigh, coeff
    cdef double tfrac, taui, lzr, tint
    cdef long zi, a, b, c, d, absd, nt
    cdef long mob[4]
    cdef int jsym
#     cdef TauPlusM tpm
#     cdef MobiusTransformation M

    # if tau.imag <= 0:
    #     raise ValueError("tau %s not in upper half-plane" % tau)
    z -= round(z.real)
    tauHigh = _findHighTau(tau, True, mob)
    a = mob[0]
    b = mob[1]
    c = mob[2]
    d = mob[3]

    tint = <int>(floor(tau.real))
    tfrac = tau.real - tint
    taui = tau.imag
    ctauplusd = (c*tint + d) + c*tfrac + c*taui*1j
    z1 = z / ctauplusd
    tau1 = _transform(mob, tau)
    # Move z1 into middle vertical strip
    z1 = z1 - <long> round(z1.real)
    # Move z to horizontal strip, keeps eta and 1/eta closer to 1
    nt = - <long>round(z1.imag/tau1.imag)
    coeff = _exppi((nt ** 2 * tau1 + 2 * nt * z1) * 1j)
    z1 = z1 + (nt * tau1)
    # Move z1 into middle vertical strip again
    z1 = z1 - <long> round(z1.real)
    jval = _theta_raw(z1, tau1)
    if c % 2 == 0:
        absd = (d if d >= 0 else -d)
        jsym = _jacobiSymbol(c, absd)
        zeta = (-1) ** ((d - 1) // 2) * jsym
    else:
        jsym = _jacobiSymbol(d, c)
        zeta = _exppi(-1j * c / 4.0) * jsym

    if jval != 0:
        jval /= zeta
        jval /= zsqrt(ctauplusd)
        # lz = np.pi * 1j * c * z ** 2 / (ctauplusd)
        lz =  1j * c * z ** 2 / (ctauplusd)
        jval *= _exppi(-lz)
        jval *= coeff
    tfrac = modf(tau.real, &tint)
    if tfrac == 0 and z.imag == 0 and modf(2 * z.real, &tint) == 0:
        jval.imag = 0
    else:
        # jval = np.real_if_close(jval)
        pass
    return jval


# from numpy import ndarray, array, imag, real, real_if_close
#
#
# cdef inline _jacobi_theta(z, tau):
#     r"""Jacobi theta function
#
#     Defined as [1]_,
#
#     .. math:: theta(z, tau) = \sum_{k=-\infty}^{\infty} exp(2\pi i k z) exp(\pi i \tau k^2)
#
#     Parameters
#     ----------
#     z : complex or float
#     tau : complex, with im(tau) > 0
#
#     Returns
#     -------
#     theta : complex
#
#     Notes
#     -----
#     For \tau with small imaginary part, the function first computes
#     a better tau to use, and applies the functional equation
#
#     .. math:: \theta(\frac{z}{c\tau+d}, \frac{a\tau+b}{c\tau+d}) = \zeta \sqrt{c\tau+d} \theta(z,\tau)
#
#     for some 8th root of unity, :math:`\zeta`.
#
#     References
#     ----------
#     .. [1] "Tata Lectures on Theta I",
#       Mumford, D. and Musili, C. and Nori, M. and Previato, E. and Stillman, M., 2006.
#       Birkhauser Boston
#     """
#     if imag(tau) <= 0:
#         raise ValueError("tau %s not in upper half-plane" % tau)
#     if isinstance(z, ndarray):
#         return array(cjacobi_theta(_, tau) for _ in z)
#     _z = 1.0*z + 0*1j
#     _tau = 1.0*tau + 0*1j
#     jval = _jacobi_theta(_z, _tau)
#     if imag(jval) == 0:
#         jval = real(jval)
#     else:
# #         jval = np.real_if_close(jval)
#         pass
#     return jval
